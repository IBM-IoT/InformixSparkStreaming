/*
** Title:          support.c
** SCCSid:         %W% %E% %U%
** CCid:           %W% %E% %U%
** Author:         Informix Software, Inc.
** Created:        08/27/1999 14:15
** Description:    This is the generated support 'C' file.
** Comments:     
**                 This file contains all the support routines needed for the
**                 DataBlade.
**                 Changes should not be made to this file since this file is
**                 always regenerated.
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "boundingbox.h"


/* {{FUNCTION(11190130-cf56-11d1-9ce6-080010e6b366) (CopySection) */
/*******************************************************************************
**
** Function name:
**
**	Gen_sscanf
**
** Description:
**
**	This function converts formatted values.  The types converted are:
**
**		Type                    Format
**		==============================
**		gl_wchar_t                %W
**		gl_mchar_t                %C
**		mi_boolean                %b
**		mi_char                   %c
**		mi_date                   %D
**		mi_datetime               %T
**		mi_decimal/mi_numeric     %N
**		mi_double_precision       %lf
**		mi_int1                   %u1
**		mi_int8                   %8
**		mi_integer                %d
**		mi_interval               %I
**		mi_long                   %ld
**		mi_money                  %m
**		mi_real                   %f
**		mi_sint1                  %1
**		mi_smallint               %2
**		mi_string                 %s
**		mi_unsigned_integer       %x
**		mi_unsigned_smallint      %u2
**		mi_wchar                  %w
**
**	Conversion is performed from GLS text to the corresponding binary
**	representation.  The GLS text is assumed to be in the server locale.
**
**	Additional information about these data types may be found in
**	The Informix Guide to SQL: Syntax - Version 9.01.
**
** Parameters:
**
**	MI_CONNECTION * Gen_Con           The database connection.
**	char *          Gen_Caller        Name of the calling function.
**	gl_mchar_t *    Gen_InData        The input string data.
**	mi_integer      Gen_InDataLen     The length of Gen_InData.
**	mi_integer      Gen_Width         Max length if data is text.
**	char *          Gen_Format        The data's format.
**	char *          Gen_Result        Place the result here.
**
** Return value:
**
**	gl_mchar_t *    The new scan position.
**
** History:
**
**	08/27/1999 - Generated by BladeSmith Version 4.00.TC1B.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Gen_sscanf FunctionId: 3AC0E360-5A81-11d0-A2E7-00AA0009BF87
**
********************************************************************************
*/
gl_mchar_t *
Gen_sscanf
(
MI_CONNECTION *            Gen_Con,                     /* The database connection.               */
char *                     Gen_Caller,                  /* Name of the calling function.          */
gl_mchar_t *               Gen_InData,                  /* The input string data.                 */
mi_integer                 Gen_InDataLen,               /* The length of Gen_InData.              */
mi_integer                 Gen_Width,                   /* Max length if data is text.            */
char *                     Gen_Format,                  /* The data's format.                     */
char *                     Gen_Result                   /* Place the result here.                 */
)
{
	gl_mchar_t *       Gen_In;                      /* Scanning ptr.                          */
	gl_mchar_t *       Gen_SaveIn;                  /* Save Gen_In here.                      */
	gl_mchar_t         Gen_NextChar;                /* Get the next char here.                */
	char *             Gen_InStart;                 /* Gen_In before advancement.             */
	gl_mchar_t *       Gen_Out;                     /* Place the GLS result here.             */
	mi_integer         Gen_ByteCount;               /* The number of bytes.                   */
	mi_integer         Gen_CharLen;                 /* Width of a character.                  */

	Gen_In        = Gen_InData;
	Gen_Out       = (gl_mchar_t *)Gen_Result;
	Gen_ByteCount = 0;

	/* Scan past non-format characters. */
	while( *Gen_Format && *Gen_In )
	{
		/* Scan past and ignore white space in the data. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );
		}

		/* Check for the format character. */
		if( *Gen_Format == '%' )
		{
			break;
		}

		/*
		**	The format character and the input string
		**	must match up to the format character.
		**	If not, issue a message.
		*/
		if( *(char *)Gen_In != *Gen_Format )
		{
			goto parse_error;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Advance to the next character. */
		++Gen_Format;
	}

	/* Check for no input data string. */
	if( *(char *)Gen_In == '\0' )
	{
		goto parse_error;
	}

	/* The following code now handles the various format types. */

	/* Check for an mi_string. */
	if( !strncmp( Gen_Format, "%s %n", 5 ) && Gen_Width )
	{
		if( '\"' != *Gen_In )
		{
			/*
			** Input parsing has failed so issue
			** the following message and quit.
			**
			** 	"Double-quoted string expected
			**	 in input in <Gen_Caller>."
			*/
			DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG7, 10 );

			/* not reached */
		}

		/* Advance past the leading quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Copy while there's sufficient room. */
		while( Gen_Width )
		{
			Gen_InStart = (char *)Gen_In;

			switch( *Gen_In )
			{
				/*
				** If '\"' is seen, check to see
				** if the next character is also
				** a '\"'. If so, '\"' is embedded.
				** Otherwise, it is EOS.
				*/
				case '\"':
					Gen_SaveIn = Gen_In;
					Gen_NextChar = *ifx_gl_mbsnext( Gen_In, 4 );
					Gen_In = Gen_SaveIn;
					if( Gen_NextChar == '\"' )
					{
						*Gen_Out++ = '\"';

						/* Advance past the first quote. */
						Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

						/* Advance past the second space. */
						Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

						break;
					}

					*Gen_Out = (char)'\0';

					/* Advance past the trailing quote. */
					Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

					/* Advance past the trailing space. */
					Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

					return Gen_In;

				case '\0':
					/*
					** Input parsing has failed so issue
					** the following message and quit.
					**
					** 	"Input string is not terminated with double-quote
					**	 in <Gen_Caller>."
					*/
					DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG9, 10 );

					/* not reached */

				default:
					Gen_CharLen = ifx_gl_mblen( Gen_In, 4);

					/* Make sure that there is enough space. */
					if( Gen_CharLen <= Gen_Width )
					{
						memcpy( Gen_Out, Gen_In, Gen_CharLen );
						Gen_Out += Gen_CharLen;
					}
					Gen_In  += Gen_CharLen;
					Gen_Width -= (char *)Gen_In - Gen_InStart;

					break;
			}
		}

		/*
		** Input string exceeded the string allocated
		** size so truncate the string.
		*/

		/*
		** Remove the last character and replace
		** with the string terminator.
		*/
		Gen_Out -= Gen_CharLen;

		/* Null terminate the output string. */
		*Gen_Out = (char)'\0';

		/* Advance to the trailing quote. */
		while( *Gen_In && *Gen_In != '"' )
		{
			/* Advance the character pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Check for trailing quote. */
		if( *Gen_In != '"' )
		{
			goto parse_error;
		}

		/* Advance past the trailing quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_integer. */
	else if( !strncmp( Gen_Format, "%d %n", 5 ) )
	{
		mi_decimal   Gen_dec_number;  /* Store an mi_decimal value here. */
		mi_integer   Gen_IntWidth;    /* Used to compute the width.      */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%d" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' integer. */
		if( dectolong( &Gen_dec_number, (long *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Ensure the number is not too wide. */
		for( Gen_IntWidth = 0;
		     Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'            ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_IntWidth;
		}

		/*
		** Check for a number that is too large.
		** The range of an unsigned integer is
		** (+/-)2,147,483,647.
		*/
		if( Gen_IntWidth > 11 )
		{
			goto parse_error;
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a double value. */
	else if( !strncmp( Gen_Format, "%lf %n", 6 ) )
	{
		gl_mchar_t * Gen_DblPtr;     /* Scanning pointer.               */
		gl_mchar_t * Gen_DblPtr2;    /* Scanning pointer.               */
		mi_integer   Gen_DblWidth;   /* Keep track of the length.       */
		char         Gen_DblStr[80]; /* Hold the mi_double string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by rstod.
		*/
		for( Gen_DblPtr   = (gl_mchar_t *)Gen_DblStr,
		     Gen_DblPtr2  = Gen_In,
		     Gen_DblWidth = 0;
				Gen_In < Gen_InData + Gen_InDataLen; )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'            ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_DblWidth += ifx_gl_mblen( Gen_In, 4 );

			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Copy the string and terminate. */
		memcpy( Gen_DblStr, Gen_DblPtr2, Gen_DblWidth );
		Gen_DblStr[Gen_DblWidth] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_DblWidth == 0 )
		{
			goto parse_error;
		}

		/* Convert from text to a binary double value. */
		if( rstod( (char *)Gen_DblStr, (double *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Advance the format string. */
		Gen_Format += 6;
	}

	/* Check for a float value. */
	else if( !strncmp( Gen_Format, "%f %n", 5 ) )
	{
		mi_double_precision Gen_dbl_number; /* Store an mi_float value here.   */
		mi_decimal          Gen_dec_number; /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%e" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' float. */
		if( dectodbl( &Gen_dec_number, &Gen_dbl_number ) != 0 )
		{
			goto parse_error;
		}
		*(float *)Gen_Result = (float)Gen_dbl_number;

		/* Scan past the float value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'            ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a long value. */
	else if( !strncmp( Gen_Format, "%ld %n", 6 ) )
	{
		mi_decimal   Gen_dec_number;  /* Store an mi_decimal value here. */
		mi_integer   Gen_LongWidth;   /* Used to compute the width.      */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%d" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' long. */
		if( dectolong( &Gen_dec_number, (long *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Ensure the number is not too wide. */
		for( Gen_LongWidth = 0;
		     Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'		   ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_LongWidth;
		}

		/*
		** Check for a number that is too large.
		** The range of an unsigned integer is
		** (+/-)2,147,483,647.
		*/
		if( Gen_LongWidth > 11 )
		{
			goto parse_error;
		}

		/* Advance the format string. */
		Gen_Format += 6;
	}

	/* Check for an int8 value. */
	else if( !strncmp( Gen_Format, "%8 %n", 5 ) )
	{
		gl_mchar_t * Gen_Int8Ptr;     /* Scanning pointer.             */
		gl_mchar_t * Gen_Int8Ptr2;    /* Scanning pointer.             */
		mi_integer   Gen_Int8Width;   /* Keep track of the length.     */
		mi_integer   Gen_Int8Ret;     /* ifx_int8cvasc return value.   */
		char         Gen_Int8Str[80]; /* Hold the mi_int8 string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by ifx_int8cvasc.
		*/
		for( Gen_Int8Ptr   = (gl_mchar_t *)Gen_Int8Str,
		     Gen_Int8Ptr2  = Gen_In,
		     Gen_Int8Width = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Keep track of how far we've advanced. */
			Gen_Int8Width += ifx_gl_mblen( Gen_In, 4 );

			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Copy the string and terminate. */
		memcpy( Gen_Int8Str, Gen_Int8Ptr2, Gen_Int8Width );
		Gen_Int8Str[Gen_Int8Width] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_Int8Width == 0 )
		{
			goto parse_error;
		}

		/* Convert the mi_int8 value from text to internal format. */
		Gen_Int8Ret = ifx_int8cvasc( Gen_Int8Str, strlen( Gen_Int8Str ),
			                     (ifx_int8_t *)Gen_Result );
		if( Gen_Int8Ret )
		{
			goto parse_error;
		}

		/* Scan past the int8 value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'            ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_Int8Width += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_int1 value. */
	else if( !strncmp( Gen_Format, "%u1 %n", 6 ) )
	{
		int Gen_Int1Result;

		if( 1 != sscanf( (char *)Gen_In, "%d %n", &Gen_Int1Result, &Gen_ByteCount ) )
		{
			goto parse_error;
		}

		/*
		** Check for a number that is too large.
		** The range of an mi_int1 is [0, 255].
		*/
		if( Gen_Int1Result > 255 )
		{
			goto parse_error;
		}

		*(mi_int1 *)Gen_Result = Gen_Int1Result;

		/* Scan to trailing white space. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first blank. */
			if( ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 6;
	}

	/* Check for an mi_smallint value. */
	else if( !strncmp( Gen_Format, "%2 %n", 5 ) )
	{
		int           Gen_SmallIntResult; /* The mi_smallint value.    */
		gl_mchar_t *  Gen_SmallIntPtr;    /* Scanning pointer.         */
		mi_integer    Gen_SmallIntWidth;  /* Keep track of the length. */
		mi_integer    Gen_ScanCount;      /* Number of bytes scanned.  */

		/* Use sscanf to scan the mi_smallint value. */
		if( 1 != sscanf( (char *)Gen_In, "%d %n", &Gen_SmallIntResult, &Gen_ScanCount ) )
		{
			goto parse_error;
		}

		/* Ensure the number is not too wide. */
		for( Gen_SmallIntPtr   = Gen_In,
		     Gen_SmallIntWidth = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_SmallIntWidth;
		}

		/*
		** Check for a number that is too large.
		** The range of an mi_smallint is
		** (+/-)32,767.
		*/
		if( Gen_SmallIntWidth > 6 )
		{
			goto parse_error;
		}

		/* Validate the value. */
		if( Gen_SmallIntResult < -32767 || 32767 < Gen_SmallIntResult )
		{
			goto parse_error;
		}

		/* Save the temporary value back into the result. */
		*(mi_smallint *)Gen_Result = Gen_SmallIntResult;

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_sint1 value. */
	else if( !strncmp( Gen_Format, "%1 %n", 5 ) )
	{
		int Gen_Int1Result;

		if( 1 != sscanf( (char *)Gen_In, "%d %n", &Gen_Int1Result, &Gen_ByteCount ) )
		{
			goto parse_error;
		}

		/*
		** Check for a number that is too large.
		** The range of an mi_sint1 is [-127, 127].
		*/
		if( Gen_Int1Result < -127 || Gen_Int1Result > 127 )
		{
			goto parse_error;
		}

		*(int1 *)Gen_Result = Gen_Int1Result;

		/* Scan to trailing white space. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_unsigned_smallint value. */
	else if( !strncmp( Gen_Format, "%u2 %n", 6 ) )
	{
		int           Gen_USmallIntResult; /* The mi_smallint value.    */
		mi_integer    Gen_USmallIntWidth;  /* Keep track of the length. */
		mi_integer    Gen_ScanCount;       /* Number of bytes scanned.  */

		/* Use sscanf to scan the mi_unsigned_smallint value. */
		if( 1 != sscanf( (char *)Gen_In, "%d %n", &Gen_USmallIntResult, &Gen_ScanCount ) )
		{
			goto parse_error;
		}

		/* Ensure the number is not too wide. */
		for( Gen_USmallIntWidth = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_USmallIntWidth;
		}

		/*
		** Check for a number that is too large.
		** The range of an mi_unsigned_smallint
		** is 0-65,535.
		*/
		if( Gen_USmallIntWidth > 6 )
		{
			goto parse_error;
		}

		/* Validate the value. */
		if( Gen_USmallIntResult < 0 || 65535 < Gen_USmallIntResult)
		{
			goto parse_error;
		}

		/* Save the temporary value back into the result. */
		*(mi_unsigned_smallint *)Gen_Result = Gen_USmallIntResult;

		/* Advance the format string. */
		Gen_Format += 6;
	}

	/*
	** Check for a boolean value.  Only 'T' or 't'
	** (for True) and  'F' or 'f' (for False)  are
	** accepted.
	*/
	else if( !strncmp( Gen_Format, "%b %n", 5 ) )
	{
		if( *(char *)Gen_In == 'T' || *(char *)Gen_In == 't' )
		{
			*(char *)Gen_Result = 1;
		}
		else if( *(char *)Gen_In == 'F' || *(char *)Gen_In == 'f' )
		{
			*(char *)Gen_Result = 0;
		}
		else
		{
			goto parse_error;
		}

		Gen_ByteCount += sizeof(char);
		Gen_In += sizeof(char);

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an unsigned int value. */
	else if( !strncmp( Gen_Format, "%x %n", 5 ) )
	{
		mi_integer Gen_UIntWidth;  /* Used to compute the width.      */
		mi_decimal Gen_dec_number; /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%u" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' unsigned integer. */
		if( dectoint( &Gen_dec_number, (int *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Scan past the number and insure the number is not too wide. */
		for( Gen_UIntWidth = 0;
		     Gen_In < Gen_InData + Gen_InDataLen &&
			!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'            ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_UIntWidth;
		}

		/*
		** Check for a number that is too large.
		** The range of an unsigned integer is
		** (+/-)2,147,483,647.
		*/
		if( Gen_UIntWidth > 11 )
		{
			goto parse_error;
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a multibyte character of maximum length 4. */
	else if( !strncmp( Gen_Format, "%W %n", 5 ) )
	{
		/* Convert the multibyte character to gl_wchar_t. */
		Gen_ByteCount += ifx_gl_mbtowc( (gl_wchar_t *)Gen_Result, Gen_In, 4 );
		Gen_In        += ifx_gl_mbtowc( (gl_wchar_t *)Gen_Result, Gen_In, 4 );

		/* Scan to trailing white space. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a wide-character. */
	/* Check for a multibyte character of max length GL_WCSIZE */
	else if( !strncmp( Gen_Format, "%w %n", 5 ) )
	{
		gl_wchar_t Gen_WideChar;
		int        Gen_NumBytes;

		/* Convert multibyte character to mi_wchar. */
		Gen_NumBytes = ifx_gl_mbtowc( (gl_wchar_t *) &Gen_WideChar, Gen_In, GL_WCSIZE );

		/* Check for an invalid character */
		if( Gen_NumBytes <= 0 )
		{
			goto parse_error;
		}

		/* Advance the input data pointer. */
		Gen_ByteCount += Gen_NumBytes;
		Gen_In        += Gen_NumBytes;

		/* Copy to the return result. */
		*((mi_wchar *)Gen_Result) = (mi_wchar) Gen_WideChar;

		/* Scan to trailing white space. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_money value. */
	else if( !strncmp( Gen_Format, "%m %n", 5 ) )
	{
		gl_mchar_t *   Gen_MoneyPtr;     /* Scanning pointer.                */
		gl_mchar_t *   Gen_MoneyPtr2;    /* Scanning pointer.                */
		mi_lvarchar *  Gen_MoneyLV;      /* mi_lvarchar ptr to Gen_MoneyStr. */
		mi_money *     Gen_MoneyVal;     /* The binary money value.          */
		mi_integer     Gen_MoneyWidth;   /* Keep track of the length.        */
		char           Gen_MoneyStr[80]; /* Hold the mi_money string here.   */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by mi_money_to_binary.
		*/
		for( Gen_MoneyPtr   = (gl_mchar_t *)Gen_MoneyStr,
		     Gen_MoneyPtr2  = Gen_In,
		     Gen_MoneyWidth = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_MoneyWidth;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_MoneyStr, Gen_MoneyPtr2,
					(int)(Gen_In - Gen_MoneyPtr2) );
		Gen_MoneyStr[Gen_In - Gen_MoneyPtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_MoneyWidth == 0 )
		{
			goto parse_error;
		}

		/* Convert the money string to mi_lvarchar. */
		Gen_MoneyLV = mi_string_to_lvarchar( Gen_MoneyStr );

		/* Check for an error in conversion. */
		if( Gen_MoneyLV == 0 )
		{
			goto parse_error;
		}

		/* Convert the money string to internal format. */
		Gen_MoneyVal = mi_money_to_binary( Gen_MoneyLV );

		/* Check for an error in conversion. */
		if( Gen_MoneyVal == NULL )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, Gen_MoneyVal, sizeof(mi_money) );

		/* ... and free the temporary money data values. */
		mi_free( Gen_MoneyLV );
		mi_free( Gen_MoneyVal );

		/* Scan past the money value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'            ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_numeric/mi_decimal value. */
	else if( !strncmp( Gen_Format, "%N %n", 5 ) )
	{
		gl_mchar_t * Gen_DecPtr;     /* Scanning pointer.                */
		gl_mchar_t * Gen_DecPtr2;    /* Scanning pointer.                */
		mi_decimal   Gen_DecVal;     /* The binary decimal value.        */
		mi_integer   Gen_DecIndex;   /* Keep track of the length.        */
		mi_integer   Gen_DecRet;     /* deccvasc return value.           */
		char         Gen_DecStr[80]; /* Hold the mi_decimal string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by deccvasc.
		*/
		for( Gen_DecPtr   = (gl_mchar_t *)Gen_DecStr,
		     Gen_DecPtr2  = Gen_In,
		     Gen_DecIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_DecIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DecStr, Gen_DecPtr2,
					(int)(Gen_In - Gen_DecPtr2) );
		Gen_DecStr[Gen_In - Gen_DecPtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_DecIndex == 0 )
		{
			goto parse_error;
		}

		/* Convert the mi_decimal value from text to internal format. */
		Gen_DecRet = deccvasc( Gen_DecStr, strlen( Gen_DecStr ), &Gen_DecVal );

		/* Check for an error in conversion. */
		if( Gen_DecRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DecVal, sizeof(mi_decimal) );

		/* Scan past the decimal value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'            ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_date value. */
	else if( !strncmp( Gen_Format, "%D %n", 5 ) )
	{
		gl_mchar_t * Gen_DatePtr;     /* Scanning pointer.             */
		gl_mchar_t * Gen_DatePtr2;    /* Scanning pointer.             */
		long         Gen_DateVal;     /* The binary date value.        */
		mi_integer   Gen_DateIndex;   /* Keep track of the length.     */
		mi_integer   Gen_RstrdateRet; /* rstrdate return value.        */
		char         Gen_DateStr[80]; /* Hold the mi_date string here. */
		int          Gen_NumBytes;    /* Number of bytes.              */

		/* The date value must be enclosed in quotes. */
		if( *Gen_In != '"' )
		{
			goto parse_error;
		}

		/* Advance past the quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by rstrdate.
		*/
		for( Gen_DatePtr   = (gl_mchar_t *)Gen_DateStr,
		     Gen_DatePtr2  = Gen_In,
		     Gen_DateIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen; )
		{
			/* Stop at the trailing quote. */
			if( *Gen_In == '"' )
			{
				break;
			}

			/* Advance the input pointer. */
			Gen_NumBytes = ifx_gl_mblen( Gen_In, 4 );
			Gen_In += Gen_NumBytes;

			/* Keep track of the length. */
			Gen_DateIndex += Gen_NumBytes;
			Gen_ByteCount += Gen_NumBytes;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DateStr, Gen_DatePtr2,
					(int)(Gen_In - Gen_DatePtr2) );
		Gen_DateStr[Gen_In - Gen_DatePtr2] = (char)'\0';

		/* Advance past the quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Check for an empty string. */
		if( Gen_DateIndex == 0 )
		{
			goto parse_error;
		}

		/* Convert the date string to internal format. */
		Gen_RstrdateRet = rstrdate( Gen_DateStr, &Gen_DateVal );

		/* Check for an error in conversion. */
		if( Gen_RstrdateRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DateVal, sizeof(mi_date) );

		/* Scan past the date string. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !ifx_gl_ismdigit( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_datetime value. */
	else if( !strncmp( Gen_Format, "%T %n", 5 ) )
	{
		gl_mchar_t * Gen_DTPtr;      /* Scanning pointer.             */
		gl_mchar_t * Gen_DTPtr2;     /* Scanning pointer.             */
		mi_datetime  Gen_DTVal;      /* The binary date value.        */
		mi_integer   Gen_DTIndex;    /* Keep track of the length.     */
		int          Gen_DtcvascRet; /* dtcvasc return value.         */
		char         Gen_DTStr[80];  /* Hold the mi_date string here. */

		/* The date time value must be enclosed in quotes. */
		if( *Gen_In != '"' )
		{
			goto parse_error;
		}

		/* Advance past the quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/*
		** Transfer the date value to a NULL terminated
		** buffer for conversion by dtcvasc.
		*/
		for( Gen_DTPtr   = (gl_mchar_t *)Gen_DTStr,
		     Gen_DTPtr2  = Gen_In,
		     Gen_DTIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen; )
		{
			/* Stop at the trailing quote. */
			if( *Gen_In == '"' )
			{
				break;
			}

			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_DTIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DTStr, Gen_DTPtr2,
					(int)(Gen_In - Gen_DTPtr2) );
		Gen_DTStr[Gen_In - Gen_DTPtr2] = (char)'\0';

		/* Advance past the quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Check for an empty string. */
		if( Gen_DTIndex == 0 )
		{
			goto parse_error;
		}

 		/*
		** Set the  mi_datetime  qualifier.   It is
		** copied from the return value's qualifier.
		*/
		Gen_DTVal.dt_qual = ((mi_datetime *)Gen_Result)->dt_qual;

		/* Convert the mi_datetime value to internal format. */
		Gen_DtcvascRet = dtcvasc( Gen_DTStr, &Gen_DTVal );

		/* Check to insure that the conversion was successful. */
		if( Gen_DtcvascRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DTVal, sizeof(mi_datetime) );

		/* Scan past the datetime string. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Handle all other types using sscanf. */
	else
	{
		if( 1 != sscanf( (char *)Gen_In, Gen_Format, Gen_Out, &Gen_ByteCount ) )
		{
			goto parse_error;
		}

		/* Advance past the data. */
		Gen_In += Gen_ByteCount;

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Satisfy any remaining non-format characters in the format string. */
	while( *Gen_Format && *Gen_In )
	{
		/* Scan past trailing white space in the data. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/*
		**	The non-format character and the input data
		**	must match. If not, issue a message.
		*/
		if( *(char *)Gen_In != *Gen_Format )
		{
			goto parse_error;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Advance to the next character. */
		++Gen_Format;
	}

	/*
	** Finally, scan past trailing spaces
	** and non-format characters.
	*/

	/* Scan past trailing white space in the data. */
	while( Gen_In < Gen_InData + Gen_InDataLen )
	{
		/* Stop at the first non-blank. */
		if( !ifx_gl_ismblank( Gen_In, 4 ) )
		{
			break;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
	}

	return Gen_In;

parse_error:

	/*
	** Input parsing has failed so issue
	** the following message and quit.
	**
	** 	"Input data format error in <Gen_Caller>."
	*/
	DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG11, 10 );

	/* not reached */
}
/* }}FUNCTION (#FF75) */


/* {{FUNCTION(11190130-cf56-11d1-9ce6-080015e6b366) (CopySection) */
/*******************************************************************************
**
** Function name:
**
**	Gen_nstrwords
**
** Description:
**
**	This function counts the number of values in a formatted string.
**
** Parameters:
**
**	gl_mchar_t *       Gen_InData                   The data to scan.
**	mi_integer         Gen_InDataLen                Length of the data.
**
** Return value:
**
**	mi_integer                                      The new scan position.
**
** History:
**
**	08/27/1999 - Generated by BladeSmith Version 4.00.TC1B.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Gen_nstrwords FunctionId: 3AC0E361-5A81-11d0-A2E7-00AA0009BF87
**
********************************************************************************
*/
mi_integer
Gen_nstrwords
(
gl_mchar_t *               Gen_InData,                  /* The data to scan.                      */
mi_integer                 Gen_InDataLen                /* Length of the data.                    */
)
{
	mi_integer         Gen_WordCount;               /* The number of words present.           */
	gl_mchar_t *       Gen_In;                      /* Scanning pointer.                      */
	char *             Gen_DataCopy;                /* A NULL terminated copy.                */
	enum
	{
		DBDK_QUOTE,
		DBDK_ESCAPE,
		DBDK_WORD,
		DBDK_SPACE
	} Gen_state;       /* Parsing state.	*/

	/* Copy the data and NULL terminate it. */
	Gen_DataCopy = (char *)mi_alloc(Gen_InDataLen + 1);
	memcpy(Gen_DataCopy, Gen_InData, Gen_InDataLen);
	Gen_DataCopy[Gen_InDataLen] = (char)'\0';
	Gen_InData = (gl_mchar_t *)Gen_DataCopy;

	/* Begin counting the words. */
	Gen_WordCount = 0;

	/* Set the initial state. */
	Gen_state = DBDK_SPACE;

	/* Point to the beginning of the input text. */
	Gen_In = Gen_InData;

	do
	{
		switch ( Gen_state )
		{
			case DBDK_ESCAPE:
				Gen_state = DBDK_QUOTE;
				break;

			case DBDK_QUOTE:
				if( '\"' == *Gen_In )
				{
					Gen_state = DBDK_SPACE;
				}
				break;

			case DBDK_WORD:
				if( '\"' == *Gen_In )
				{
					Gen_WordCount++, Gen_state = DBDK_QUOTE;
				}
				else if( ifx_gl_ismspace( Gen_In, 4 ) )
				{
					Gen_state = DBDK_SPACE;
				}
				break;

			case DBDK_SPACE:
				if( '\"' == *Gen_In )
				{
					Gen_WordCount++, Gen_state = DBDK_QUOTE;
				}
				else if( !ifx_gl_ismspace( Gen_In, 4 ) )
				{
					Gen_WordCount++, Gen_state = DBDK_WORD;
				}
				break;
		}

		/* Advance the pointer. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
	}
	while( *Gen_In != '\0' );

	/* Free the copy of the data. */
	mi_free(Gen_DataCopy);

	return Gen_WordCount;
}
/* }}FUNCTION (#DJUM) */


/* {{FUNCTION(11190130-cf56-11d1-9ce6-080025e6b366) (CopySection) */
/*******************************************************************************
**
** Function name:
**
**	Gen_Trace
**
** Description:
**
**	This function writes trace information to the trace file.
**
**	Complete information about tracing may be found in
**	the INFORMIX-DataBlade API, User's Guide, Version 9.0.
**
**	To enable tracing, you must first create a trace class
**	by inserting a record into the systraceclasses system
**	catalog:
**
**		insert into informix.systraceclasses(name)
**		values('BoundingBox');
**
**	The name of the trace file must be set. If the file name
**	is not set, the server uses a default file name:
**	the session id followed by ".trc" in the /tmp directory.
**	Use "onstat -g ses" to get the session id.
**
**	The following code snippet may be used to set the name
**	of the output trace file from within your code.
**
**		mi_tracefile_set( "/yourpath/yourfile.trc" );
**
**	Alternately, the TraceSet_idn_range procedure may be
**	used from SQL to set the trace file name and trace threshold
**	level.  See this procedure for more details.
**
**	To insure that tracing text  actually  appears in the
**	output trace file, SERVER_LOCALE, CLIENT_LOCALE,  and
**	DB_LOCALE must be set in the environment to the
**	appropriate locale (e.g., "en_us.1252").
**
** Parameters:
**
**	MI_CONNECTION *    Gen_Con        The database connection.
**	char *             Gen_Caller     Call originated from this routine.
**	char *             Gen_FileName   Call originated in this file.
**	mi_integer         Gen_LineNo     Call originated on this line.
**	char *             Gen_MsgNo      ERRORMESG number.
**	char *             Gen_Class      Tracing class.
**	mi_integer         Gen_Threshold  Tracing threshold.
**	mi_integer         Gen_MsgType    MI_SQL | MI_MESSAGE | DBDK_TRACE.
**
** Return value:
**
**	None.
**
** History:
**
**	08/27/1999 - Generated by BladeSmith Version 4.00.TC1B.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Gen_Trace FunctionId: 59DEDB71-760B-11d0-A2EC-00AA0009BF87
**
********************************************************************************
*/
void
Gen_Trace
(
MI_CONNECTION *            Gen_Con,                     /* The database connection.               */
char *                     Gen_Caller,                  /* Call originated from this routine.     */
char *                     Gen_FileName,                /* Call originated in this file.          */
mi_integer                 Gen_LineNo,                  /* Call originated on this line.          */
char *                     Gen_MsgNo,                   /* ERRORMESG number.                      */
char *                     Gen_Class,                   /* Tracing class.                         */
mi_integer                 Gen_Threshold,               /* Tracing threshold.                     */
mi_integer                 Gen_MsgType                  /* MI_SQL | MI_MESSAGE | DBDK_TRACE.      */
)
{
	MI_CONNECTION *    Gen_TraceCon;  /* The database connection.           */

	/* Route the message to the trace file? */
	if( Gen_MsgType & DBDK_TRACE )
	{
		/* Write the message to the trace file. */
		GL_DPRINTF( Gen_Class,
			    Gen_Threshold,
			    (
			        Gen_MsgNo,
			        "FUNCTION%s", Gen_Caller,      /* Substitute the caller here.    */
			        "FILENAME%s", Gen_FileName,    /* Substitute the file name here. */
			        "LINENO%d",   Gen_LineNo,      /* Substitute the line info here. */
			        MI_LIST_END                    /* Terminate the list!!           */
			    )
			  );
	}

	/* Mask off the mi_db_error_raise flags. */
	Gen_MsgType &= 0xffff;

	/* Route the message back to the user? */
	if( Gen_MsgType )
	{
		/*
		** Obtain a connection for mi_db_error_raise.
		** If available, use the connection that  has
		** already been established.
		*/
		if( Gen_Con == NULL )
		{
			/* No connection is available so open a new one. */
			Gen_TraceCon = mi_open( NULL, NULL, NULL );
		}
		else
		{
			Gen_TraceCon = Gen_Con;
		}

		/* If requested, also write the message to the user. */
		mi_db_error_raise( Gen_TraceCon,               /* This is the connection handle. */
			           Gen_MsgType,                /* Route to the user.             */
			           Gen_MsgNo,                  /* Print this message.            */
			           "FUNCTION%s", Gen_Caller,   /* Substitute the caller here.    */
			           (char *)NULL );             /* Terminator.                    */

		/*
		** mi_db_error_raise may not return
		** and this line may not be reached.
		*/
	}
}
/* }}FUNCTION (#Q4FA) */


#ifdef __cplusplus

}

#endif


